// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package resilience

import (
	"context"
	"sync"
)

// Ensure, that ProducerMock does implement Producer.
// If this is not the case, regenerate this file with moq.
var _ Producer = &ProducerMock{}

// ProducerMock is a mock implementation of Producer.
//
//	func TestSomethingThatUsesProducer(t *testing.T) {
//
//		// make and configure a mocked Producer
//		mockedProducer := &ProducerMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ProduceFunc: func(ctx context.Context, topic string, msg Message) error {
//				panic("mock out the Produce method")
//			},
//			ProduceBatchFunc: func(ctx context.Context, messages []MessageTarget) error {
//				panic("mock out the ProduceBatch method")
//			},
//		}
//
//		// use mockedProducer in code that requires Producer
//		// and then make assertions.
//
//	}
type ProducerMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ProduceFunc mocks the Produce method.
	ProduceFunc func(ctx context.Context, topic string, msg Message) error

	// ProduceBatchFunc mocks the ProduceBatch method.
	ProduceBatchFunc func(ctx context.Context, messages []MessageTarget) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct{}
		// Produce holds details about calls to the Produce method.
		Produce []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topic is the topic argument value.
			Topic string
			// Msg is the msg argument value.
			Msg Message
		}
		// ProduceBatch holds details about calls to the ProduceBatch method.
		ProduceBatch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Messages is the messages argument value.
			Messages []MessageTarget
		}
	}
	lockClose        sync.RWMutex
	lockProduce      sync.RWMutex
	lockProduceBatch sync.RWMutex
}

// Close calls CloseFunc.
func (mock *ProducerMock) Close() error {
	if mock.CloseFunc == nil {
		panic("ProducerMock.CloseFunc: method is nil but Producer.Close was just called")
	}
	callInfo := struct{}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedProducer.CloseCalls())
func (mock *ProducerMock) CloseCalls() []struct{} {
	var calls []struct{}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Produce calls ProduceFunc.
func (mock *ProducerMock) Produce(ctx context.Context, topic string, msg Message) error {
	if mock.ProduceFunc == nil {
		panic("ProducerMock.ProduceFunc: method is nil but Producer.Produce was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Topic string
		Msg   Message
	}{
		Ctx:   ctx,
		Topic: topic,
		Msg:   msg,
	}
	mock.lockProduce.Lock()
	mock.calls.Produce = append(mock.calls.Produce, callInfo)
	mock.lockProduce.Unlock()
	return mock.ProduceFunc(ctx, topic, msg)
}

// ProduceCalls gets all the calls that were made to Produce.
// Check the length with:
//
//	len(mockedProducer.ProduceCalls())
func (mock *ProducerMock) ProduceCalls() []struct {
	Ctx   context.Context
	Topic string
	Msg   Message
} {
	var calls []struct {
		Ctx   context.Context
		Topic string
		Msg   Message
	}
	mock.lockProduce.RLock()
	calls = mock.calls.Produce
	mock.lockProduce.RUnlock()
	return calls
}

// ProduceBatch calls ProduceBatchFunc.
func (mock *ProducerMock) ProduceBatch(ctx context.Context, messages []MessageTarget) error {
	if mock.ProduceBatchFunc == nil {
		panic("ProducerMock.ProduceBatchFunc: method is nil but Producer.ProduceBatch was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Messages []MessageTarget
	}{
		Ctx:      ctx,
		Messages: messages,
	}
	mock.lockProduceBatch.Lock()
	mock.calls.ProduceBatch = append(mock.calls.ProduceBatch, callInfo)
	mock.lockProduceBatch.Unlock()
	return mock.ProduceBatchFunc(ctx, messages)
}

// ProduceBatchCalls gets all the calls that were made to ProduceBatch.
// Check the length with:
//
//	len(mockedProducer.ProduceBatchCalls())
func (mock *ProducerMock) ProduceBatchCalls() []struct {
	Ctx      context.Context
	Messages []MessageTarget
} {
	var calls []struct {
		Ctx      context.Context
		Messages []MessageTarget
	}
	mock.lockProduceBatch.RLock()
	calls = mock.calls.ProduceBatch
	mock.lockProduceBatch.RUnlock()
	return calls
}

// Ensure, that ConsumerMock does implement Consumer.
// If this is not the case, regenerate this file with moq.
var _ Consumer = &ConsumerMock{}

// ConsumerMock is a mock implementation of Consumer.
//
//	func TestSomethingThatUsesConsumer(t *testing.T) {
//
//		// make and configure a mocked Consumer
//		mockedConsumer := &ConsumerMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ConsumeFunc: func(ctx context.Context, topics []string, handler ConsumerHandler) error {
//				panic("mock out the Consume method")
//			},
//		}
//
//		// use mockedConsumer in code that requires Consumer
//		// and then make assertions.
//
//	}
type ConsumerMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ConsumeFunc mocks the Consume method.
	ConsumeFunc func(ctx context.Context, topics []string, handler ConsumerHandler) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct{}
		// Consume holds details about calls to the Consume method.
		Consume []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topics is the topics argument value.
			Topics []string
			// Handler is the handler argument value.
			Handler ConsumerHandler
		}
	}
	lockClose   sync.RWMutex
	lockConsume sync.RWMutex
}

// Close calls CloseFunc.
func (mock *ConsumerMock) Close() error {
	if mock.CloseFunc == nil {
		panic("ConsumerMock.CloseFunc: method is nil but Consumer.Close was just called")
	}
	callInfo := struct{}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedConsumer.CloseCalls())
func (mock *ConsumerMock) CloseCalls() []struct{} {
	var calls []struct{}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Consume calls ConsumeFunc.
func (mock *ConsumerMock) Consume(ctx context.Context, topics []string, handler ConsumerHandler) error {
	if mock.ConsumeFunc == nil {
		panic("ConsumerMock.ConsumeFunc: method is nil but Consumer.Consume was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Topics  []string
		Handler ConsumerHandler
	}{
		Ctx:     ctx,
		Topics:  topics,
		Handler: handler,
	}
	mock.lockConsume.Lock()
	mock.calls.Consume = append(mock.calls.Consume, callInfo)
	mock.lockConsume.Unlock()
	return mock.ConsumeFunc(ctx, topics, handler)
}

// ConsumeCalls gets all the calls that were made to Consume.
// Check the length with:
//
//	len(mockedConsumer.ConsumeCalls())
func (mock *ConsumerMock) ConsumeCalls() []struct {
	Ctx     context.Context
	Topics  []string
	Handler ConsumerHandler
} {
	var calls []struct {
		Ctx     context.Context
		Topics  []string
		Handler ConsumerHandler
	}
	mock.lockConsume.RLock()
	calls = mock.calls.Consume
	mock.lockConsume.RUnlock()
	return calls
}

// Ensure, that ConsumerFactoryMock does implement ConsumerFactory.
// If this is not the case, regenerate this file with moq.
var _ ConsumerFactory = &ConsumerFactoryMock{}

// ConsumerFactoryMock is a mock implementation of ConsumerFactory.
//
//	func TestSomethingThatUsesConsumerFactory(t *testing.T) {
//
//		// make and configure a mocked ConsumerFactory
//		mockedConsumerFactory := &ConsumerFactoryMock{
//			NewConsumerFunc: func(groupID string) (Consumer, error) {
//				panic("mock out the NewConsumer method")
//			},
//		}
//
//		// use mockedConsumerFactory in code that requires ConsumerFactory
//		// and then make assertions.
//
//	}
type ConsumerFactoryMock struct {
	// NewConsumerFunc mocks the NewConsumer method.
	NewConsumerFunc func(groupID string) (Consumer, error)

	// calls tracks calls to the methods.
	calls struct {
		// NewConsumer holds details about calls to the NewConsumer method.
		NewConsumer []struct {
			// GroupID is the groupID argument value.
			GroupID string
		}
	}
	lockNewConsumer sync.RWMutex
}

// NewConsumer calls NewConsumerFunc.
func (mock *ConsumerFactoryMock) NewConsumer(groupID string) (Consumer, error) {
	if mock.NewConsumerFunc == nil {
		panic("ConsumerFactoryMock.NewConsumerFunc: method is nil but ConsumerFactory.NewConsumer was just called")
	}
	callInfo := struct {
		GroupID string
	}{
		GroupID: groupID,
	}
	mock.lockNewConsumer.Lock()
	mock.calls.NewConsumer = append(mock.calls.NewConsumer, callInfo)
	mock.lockNewConsumer.Unlock()
	return mock.NewConsumerFunc(groupID)
}

// NewConsumerCalls gets all the calls that were made to NewConsumer.
// Check the length with:
//
//	len(mockedConsumerFactory.NewConsumerCalls())
func (mock *ConsumerFactoryMock) NewConsumerCalls() []struct {
	GroupID string
} {
	var calls []struct {
		GroupID string
	}
	mock.lockNewConsumer.RLock()
	calls = mock.calls.NewConsumer
	mock.lockNewConsumer.RUnlock()
	return calls
}

// Ensure, that AdminMock does implement Admin.
// If this is not the case, regenerate this file with moq.
var _ Admin = &AdminMock{}

// AdminMock is a mock implementation of Admin.
//
//	func TestSomethingThatUsesAdmin(t *testing.T) {
//
//		// make and configure a mocked Admin
//		mockedAdmin := &AdminMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			CreateTopicFunc: func(ctx context.Context, name string, partitions int32, replicationFactor int16, config map[string]string) error {
//				panic("mock out the CreateTopic method")
//			},
//			DeleteConsumerGroupFunc: func(ctx context.Context, groupID string) error {
//				panic("mock out the DeleteConsumerGroup method")
//			},
//			DescribeTopicsFunc: func(ctx context.Context, topics []string) ([]TopicMetadata, error) {
//				panic("mock out the DescribeTopics method")
//			},
//		}
//
//		// use mockedAdmin in code that requires Admin
//		// and then make assertions.
//
//	}
type AdminMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// CreateTopicFunc mocks the CreateTopic method.
	CreateTopicFunc func(ctx context.Context, name string, partitions int32, replicationFactor int16, config map[string]string) error

	// DeleteConsumerGroupFunc mocks the DeleteConsumerGroup method.
	DeleteConsumerGroupFunc func(ctx context.Context, groupID string) error

	// DescribeTopicsFunc mocks the DescribeTopics method.
	DescribeTopicsFunc func(ctx context.Context, topics []string) ([]TopicMetadata, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct{}
		// CreateTopic holds details about calls to the CreateTopic method.
		CreateTopic []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Partitions is the partitions argument value.
			Partitions int32
			// ReplicationFactor is the replicationFactor argument value.
			ReplicationFactor int16
			// Config is the config argument value.
			Config map[string]string
		}
		// DeleteConsumerGroup holds details about calls to the DeleteConsumerGroup method.
		DeleteConsumerGroup []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GroupID is the groupID argument value.
			GroupID string
		}
		// DescribeTopics holds details about calls to the DescribeTopics method.
		DescribeTopics []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topics is the topics argument value.
			Topics []string
		}
	}
	lockClose               sync.RWMutex
	lockCreateTopic         sync.RWMutex
	lockDeleteConsumerGroup sync.RWMutex
	lockDescribeTopics      sync.RWMutex
}

// Close calls CloseFunc.
func (mock *AdminMock) Close() error {
	if mock.CloseFunc == nil {
		panic("AdminMock.CloseFunc: method is nil but Admin.Close was just called")
	}
	callInfo := struct{}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedAdmin.CloseCalls())
func (mock *AdminMock) CloseCalls() []struct{} {
	var calls []struct{}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// CreateTopic calls CreateTopicFunc.
func (mock *AdminMock) CreateTopic(ctx context.Context, name string, partitions int32, replicationFactor int16, config map[string]string) error {
	if mock.CreateTopicFunc == nil {
		panic("AdminMock.CreateTopicFunc: method is nil but Admin.CreateTopic was just called")
	}
	callInfo := struct {
		Ctx               context.Context
		Name              string
		Partitions        int32
		ReplicationFactor int16
		Config            map[string]string
	}{
		Ctx:               ctx,
		Name:              name,
		Partitions:        partitions,
		ReplicationFactor: replicationFactor,
		Config:            config,
	}
	mock.lockCreateTopic.Lock()
	mock.calls.CreateTopic = append(mock.calls.CreateTopic, callInfo)
	mock.lockCreateTopic.Unlock()
	return mock.CreateTopicFunc(ctx, name, partitions, replicationFactor, config)
}

// CreateTopicCalls gets all the calls that were made to CreateTopic.
// Check the length with:
//
//	len(mockedAdmin.CreateTopicCalls())
func (mock *AdminMock) CreateTopicCalls() []struct {
	Ctx               context.Context
	Name              string
	Partitions        int32
	ReplicationFactor int16
	Config            map[string]string
} {
	var calls []struct {
		Ctx               context.Context
		Name              string
		Partitions        int32
		ReplicationFactor int16
		Config            map[string]string
	}
	mock.lockCreateTopic.RLock()
	calls = mock.calls.CreateTopic
	mock.lockCreateTopic.RUnlock()
	return calls
}

// DeleteConsumerGroup calls DeleteConsumerGroupFunc.
func (mock *AdminMock) DeleteConsumerGroup(ctx context.Context, groupID string) error {
	if mock.DeleteConsumerGroupFunc == nil {
		panic("AdminMock.DeleteConsumerGroupFunc: method is nil but Admin.DeleteConsumerGroup was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		GroupID string
	}{
		Ctx:     ctx,
		GroupID: groupID,
	}
	mock.lockDeleteConsumerGroup.Lock()
	mock.calls.DeleteConsumerGroup = append(mock.calls.DeleteConsumerGroup, callInfo)
	mock.lockDeleteConsumerGroup.Unlock()
	return mock.DeleteConsumerGroupFunc(ctx, groupID)
}

// DeleteConsumerGroupCalls gets all the calls that were made to DeleteConsumerGroup.
// Check the length with:
//
//	len(mockedAdmin.DeleteConsumerGroupCalls())
func (mock *AdminMock) DeleteConsumerGroupCalls() []struct {
	Ctx     context.Context
	GroupID string
} {
	var calls []struct {
		Ctx     context.Context
		GroupID string
	}
	mock.lockDeleteConsumerGroup.RLock()
	calls = mock.calls.DeleteConsumerGroup
	mock.lockDeleteConsumerGroup.RUnlock()
	return calls
}

// DescribeTopics calls DescribeTopicsFunc.
func (mock *AdminMock) DescribeTopics(ctx context.Context, topics []string) ([]TopicMetadata, error) {
	if mock.DescribeTopicsFunc == nil {
		panic("AdminMock.DescribeTopicsFunc: method is nil but Admin.DescribeTopics was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Topics []string
	}{
		Ctx:    ctx,
		Topics: topics,
	}
	mock.lockDescribeTopics.Lock()
	mock.calls.DescribeTopics = append(mock.calls.DescribeTopics, callInfo)
	mock.lockDescribeTopics.Unlock()
	return mock.DescribeTopicsFunc(ctx, topics)
}

// DescribeTopicsCalls gets all the calls that were made to DescribeTopics.
// Check the length with:
//
//	len(mockedAdmin.DescribeTopicsCalls())
func (mock *AdminMock) DescribeTopicsCalls() []struct {
	Ctx    context.Context
	Topics []string
} {
	var calls []struct {
		Ctx    context.Context
		Topics []string
	}
	mock.lockDescribeTopics.RLock()
	calls = mock.calls.DescribeTopics
	mock.lockDescribeTopics.RUnlock()
	return calls
}

// Ensure, that LoggerMock does implement Logger.
// If this is not the case, regenerate this file with moq.
var _ Logger = &LoggerMock{}

// LoggerMock is a mock implementation of Logger.
//
//	func TestSomethingThatUsesLogger(t *testing.T) {
//
//		// make and configure a mocked Logger
//		mockedLogger := &LoggerMock{
//			DebugFunc: func(msg string, fields ...any)  {
//				panic("mock out the Debug method")
//			},
//			ErrorFunc: func(msg string, fields ...any)  {
//				panic("mock out the Error method")
//			},
//			InfoFunc: func(msg string, fields ...any)  {
//				panic("mock out the Info method")
//			},
//			WarnFunc: func(msg string, fields ...any)  {
//				panic("mock out the Warn method")
//			},
//		}
//
//		// use mockedLogger in code that requires Logger
//		// and then make assertions.
//
//	}
type LoggerMock struct {
	// DebugFunc mocks the Debug method.
	DebugFunc func(msg string, fields ...any)

	// ErrorFunc mocks the Error method.
	ErrorFunc func(msg string, fields ...any)

	// InfoFunc mocks the Info method.
	InfoFunc func(msg string, fields ...any)

	// WarnFunc mocks the Warn method.
	WarnFunc func(msg string, fields ...any)

	// calls tracks calls to the methods.
	calls struct {
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// Msg is the msg argument value.
			Msg string
			// Fields is the fields argument value.
			Fields []any
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// Msg is the msg argument value.
			Msg string
			// Fields is the fields argument value.
			Fields []any
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Msg is the msg argument value.
			Msg string
			// Fields is the fields argument value.
			Fields []any
		}
		// Warn holds details about calls to the Warn method.
		Warn []struct {
			// Msg is the msg argument value.
			Msg string
			// Fields is the fields argument value.
			Fields []any
		}
	}
	lockDebug sync.RWMutex
	lockError sync.RWMutex
	lockInfo  sync.RWMutex
	lockWarn  sync.RWMutex
}

// Debug calls DebugFunc.
func (mock *LoggerMock) Debug(msg string, fields ...any) {
	if mock.DebugFunc == nil {
		panic("LoggerMock.DebugFunc: method is nil but Logger.Debug was just called")
	}
	callInfo := struct {
		Msg    string
		Fields []any
	}{
		Msg:    msg,
		Fields: fields,
	}
	mock.lockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	mock.lockDebug.Unlock()
	mock.DebugFunc(msg, fields...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//
//	len(mockedLogger.DebugCalls())
func (mock *LoggerMock) DebugCalls() []struct {
	Msg    string
	Fields []any
} {
	var calls []struct {
		Msg    string
		Fields []any
	}
	mock.lockDebug.RLock()
	calls = mock.calls.Debug
	mock.lockDebug.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *LoggerMock) Error(msg string, fields ...any) {
	if mock.ErrorFunc == nil {
		panic("LoggerMock.ErrorFunc: method is nil but Logger.Error was just called")
	}
	callInfo := struct {
		Msg    string
		Fields []any
	}{
		Msg:    msg,
		Fields: fields,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	mock.ErrorFunc(msg, fields...)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//
//	len(mockedLogger.ErrorCalls())
func (mock *LoggerMock) ErrorCalls() []struct {
	Msg    string
	Fields []any
} {
	var calls []struct {
		Msg    string
		Fields []any
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *LoggerMock) Info(msg string, fields ...any) {
	if mock.InfoFunc == nil {
		panic("LoggerMock.InfoFunc: method is nil but Logger.Info was just called")
	}
	callInfo := struct {
		Msg    string
		Fields []any
	}{
		Msg:    msg,
		Fields: fields,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	mock.InfoFunc(msg, fields...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//
//	len(mockedLogger.InfoCalls())
func (mock *LoggerMock) InfoCalls() []struct {
	Msg    string
	Fields []any
} {
	var calls []struct {
		Msg    string
		Fields []any
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// Warn calls WarnFunc.
func (mock *LoggerMock) Warn(msg string, fields ...any) {
	if mock.WarnFunc == nil {
		panic("LoggerMock.WarnFunc: method is nil but Logger.Warn was just called")
	}
	callInfo := struct {
		Msg    string
		Fields []any
	}{
		Msg:    msg,
		Fields: fields,
	}
	mock.lockWarn.Lock()
	mock.calls.Warn = append(mock.calls.Warn, callInfo)
	mock.lockWarn.Unlock()
	mock.WarnFunc(msg, fields...)
}

// WarnCalls gets all the calls that were made to Warn.
// Check the length with:
//
//	len(mockedLogger.WarnCalls())
func (mock *LoggerMock) WarnCalls() []struct {
	Msg    string
	Fields []any
} {
	var calls []struct {
		Msg    string
		Fields []any
	}
	mock.lockWarn.RLock()
	calls = mock.calls.Warn
	mock.lockWarn.RUnlock()
	return calls
}

// Ensure, that StateCoordinatorMock does implement StateCoordinator.
// If this is not the case, regenerate this file with moq.
var _ StateCoordinator = &StateCoordinatorMock{}

// StateCoordinatorMock is a mock implementation of StateCoordinator.
//
//	func TestSomethingThatUsesStateCoordinator(t *testing.T) {
//
//		// make and configure a mocked StateCoordinator
//		mockedStateCoordinator := &StateCoordinatorMock{
//			AcquireFunc: func(ctx context.Context, msg *InternalMessage, originalTopic string) error {
//				panic("mock out the Acquire method")
//			},
//			IsLockedFunc: func(ctx context.Context, msg *InternalMessage) bool {
//				panic("mock out the IsLocked method")
//			},
//			ReleaseFunc: func(ctx context.Context, msg *InternalMessage) error {
//				panic("mock out the Release method")
//			},
//			StartFunc: func(ctx context.Context, topic string) error {
//				panic("mock out the Start method")
//			},
//		}
//
//		// use mockedStateCoordinator in code that requires StateCoordinator
//		// and then make assertions.
//
//	}
type StateCoordinatorMock struct {
	// AcquireFunc mocks the Acquire method.
	AcquireFunc func(ctx context.Context, msg *InternalMessage, originalTopic string) error

	// IsLockedFunc mocks the IsLocked method.
	IsLockedFunc func(ctx context.Context, msg *InternalMessage) bool

	// ReleaseFunc mocks the Release method.
	ReleaseFunc func(ctx context.Context, msg *InternalMessage) error

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, topic string) error

	// calls tracks calls to the methods.
	calls struct {
		// Acquire holds details about calls to the Acquire method.
		Acquire []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg *InternalMessage
			// OriginalTopic is the originalTopic argument value.
			OriginalTopic string
		}
		// IsLocked holds details about calls to the IsLocked method.
		IsLocked []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg *InternalMessage
		}
		// Release holds details about calls to the Release method.
		Release []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg *InternalMessage
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topic is the topic argument value.
			Topic string
		}
	}
	lockAcquire  sync.RWMutex
	lockIsLocked sync.RWMutex
	lockRelease  sync.RWMutex
	lockStart    sync.RWMutex
}

// Acquire calls AcquireFunc.
func (mock *StateCoordinatorMock) Acquire(ctx context.Context, msg *InternalMessage, originalTopic string) error {
	if mock.AcquireFunc == nil {
		panic("StateCoordinatorMock.AcquireFunc: method is nil but StateCoordinator.Acquire was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Msg           *InternalMessage
		OriginalTopic string
	}{
		Ctx:           ctx,
		Msg:           msg,
		OriginalTopic: originalTopic,
	}
	mock.lockAcquire.Lock()
	mock.calls.Acquire = append(mock.calls.Acquire, callInfo)
	mock.lockAcquire.Unlock()
	return mock.AcquireFunc(ctx, msg, originalTopic)
}

// AcquireCalls gets all the calls that were made to Acquire.
// Check the length with:
//
//	len(mockedStateCoordinator.AcquireCalls())
func (mock *StateCoordinatorMock) AcquireCalls() []struct {
	Ctx           context.Context
	Msg           *InternalMessage
	OriginalTopic string
} {
	var calls []struct {
		Ctx           context.Context
		Msg           *InternalMessage
		OriginalTopic string
	}
	mock.lockAcquire.RLock()
	calls = mock.calls.Acquire
	mock.lockAcquire.RUnlock()
	return calls
}

// IsLocked calls IsLockedFunc.
func (mock *StateCoordinatorMock) IsLocked(ctx context.Context, msg *InternalMessage) bool {
	if mock.IsLockedFunc == nil {
		panic("StateCoordinatorMock.IsLockedFunc: method is nil but StateCoordinator.IsLocked was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg *InternalMessage
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockIsLocked.Lock()
	mock.calls.IsLocked = append(mock.calls.IsLocked, callInfo)
	mock.lockIsLocked.Unlock()
	return mock.IsLockedFunc(ctx, msg)
}

// IsLockedCalls gets all the calls that were made to IsLocked.
// Check the length with:
//
//	len(mockedStateCoordinator.IsLockedCalls())
func (mock *StateCoordinatorMock) IsLockedCalls() []struct {
	Ctx context.Context
	Msg *InternalMessage
} {
	var calls []struct {
		Ctx context.Context
		Msg *InternalMessage
	}
	mock.lockIsLocked.RLock()
	calls = mock.calls.IsLocked
	mock.lockIsLocked.RUnlock()
	return calls
}

// Release calls ReleaseFunc.
func (mock *StateCoordinatorMock) Release(ctx context.Context, msg *InternalMessage) error {
	if mock.ReleaseFunc == nil {
		panic("StateCoordinatorMock.ReleaseFunc: method is nil but StateCoordinator.Release was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg *InternalMessage
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockRelease.Lock()
	mock.calls.Release = append(mock.calls.Release, callInfo)
	mock.lockRelease.Unlock()
	return mock.ReleaseFunc(ctx, msg)
}

// ReleaseCalls gets all the calls that were made to Release.
// Check the length with:
//
//	len(mockedStateCoordinator.ReleaseCalls())
func (mock *StateCoordinatorMock) ReleaseCalls() []struct {
	Ctx context.Context
	Msg *InternalMessage
} {
	var calls []struct {
		Ctx context.Context
		Msg *InternalMessage
	}
	mock.lockRelease.RLock()
	calls = mock.calls.Release
	mock.lockRelease.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *StateCoordinatorMock) Start(ctx context.Context, topic string) error {
	if mock.StartFunc == nil {
		panic("StateCoordinatorMock.StartFunc: method is nil but StateCoordinator.Start was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Topic string
	}{
		Ctx:   ctx,
		Topic: topic,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, topic)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedStateCoordinator.StartCalls())
func (mock *StateCoordinatorMock) StartCalls() []struct {
	Ctx   context.Context
	Topic string
} {
	var calls []struct {
		Ctx   context.Context
		Topic string
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}
